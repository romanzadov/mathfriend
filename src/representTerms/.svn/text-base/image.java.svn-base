package representTerms;

import java.io.StringReader;
import java.util.ArrayList;

import parse.path;
import tree.term;
import tree.operators.times;
import android.graphics.Color;
import android.util.Log;
import container.AbsoluteContainer;
import container.RelativeContainer;
import display.point;
import display.rectangle;
import display.stringofrects;


public class image implements Cloneable{

	public static final String TAG = "image";
	public String st;
	public term tr;

	public ArrayList<stringrect>relativeContainers  = new ArrayList<stringrect>();
	public ArrayList<stringrect>historyContainers =  new ArrayList<stringrect>();
	public int background = Color.WHITE;
	public int wordcolor = Color.BLACK;

	public point bel =  new point();

	public double rotation =0 ;
	public double scalefactor =1;
	String arg = null;

	public image(){}
	@Override
	public Object clone() throws CloneNotSupportedException {
		image clone = (image)super.clone();

		if(this.tr != null){
			clone.tr = (term) this.tr.clone();
		}

		clone.bel = (point)this.bel.clone();
		return clone;
	}

	@Override
	public String toString(){
		String st="";
		if(tr == null ){return null;}
		else{
			if(tr !=null && tr.container!=null){
				st+="h "+tr.container.height+" w "+tr.container.width+"|";
			}
			st += "bel: "+bel.toString()+" term: "+tr.toString();
			return st;
		}
	}



	public image(term term, point bl,  String argument){
		tr = term;
		bel = bl;
		arg = argument;
		st = tr.toString();
	}

	public image(String myst,   int font, int screenWidth, int screenHeight){
		path pa = new path();
		tr = pa.pathway(myst);
		st = myst;
	}


	public image(String myst, point bl){
		path pa = new path();
		tr = pa.pathway(myst);
		bel = bl;
		st = myst;
	}

	public void imagemove(term term, point bl, String argument){
		tr = term;
		bel = bl;
		arg = argument;

	}

	public ArrayList<stringrect> getRelativeContainers(){
		reset();
		return relativeContainers;
	}

	private void setRelativeContainers(){
		RelativeContainer dc = new RelativeContainer();
		dc.drawelement(tr);
		stringofrects sp = new stringofrects();
		relativeContainers = sp.writeme(tr);
	}

	public ArrayList<stringrect> getAbsoluteContainers(int font, point bel){
		reset();
		ArrayList<stringrect> relativeContainers = getRelativeContainers();
		ArrayList<stringrect> absoluteContainers = new ArrayList<stringrect>();
		for(int i =0; i<relativeContainers.size(); i++){
			rectangle rc = relativeContainers.get(i).container;
			stringrect ac = new stringrect();
			ac.container.bl.x    = rc.bl.x*font;
			ac.container.bl.y    = rc.bl.y*font;
			ac.container.width   = rc.width*font;
			ac.container.height  = rc.height*font;

			ac.container.bl.x    = rc.bl.x*font+bel.x;
			ac.container.bl.y    = -rc.bl.y*font+bel.y;

			ac.fontscale = relativeContainers.get(i).fontscale;
			ac.hasParens = relativeContainers.get(i).hasParens;
			ac.term = relativeContainers.get(i).term;
			ac.todraw = relativeContainers.get(i).todraw;

			absoluteContainers.add(ac);
		}
		return absoluteContainers;
	}

	private void reset(){
		path pa = new path();
		tr = pa.pathway(st);
		relativeContainers  = new ArrayList<stringrect>();
		background = Color.WHITE;
		wordcolor = Color.BLACK;

		bel =  new point();

		rotation = 0;
		scalefactor= 1;
		String arg = null;

		setRelativeContainers();

	}
}
